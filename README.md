# JavaBeginTasks
Задания на зачёт

Каждый создаёт свою ветку от main с названием student/номер_группы_фамилия_первая_буква_имени_номер_билета. Делаем пуш только в конце экзамена. Если пуша в конце экзамена нет, то считается, что задача не сдана.

Билет №1:
1.  Интерфейс Map<K,V>. Основные реализации. Как работают вставка, удаление, поиск элемента на примере одной из реализаций.
2.  Многопоточность. Ключевые слова volatile, synchronized. Методы notify, notifyAll, wait.
3.  Реализуйте программу на Java, которая реализует класс 'грузовик' с характеристиками скорость, объем топливного бака, коллекция груза (LinkedList) - тип груза любой, но все элементы груза - однотипные. Реализовать у класса интерфейсы Comparable, Iterable c учетом характеристик класса.

Билет №2:
1.  Библиотека java.util.concurrent.*. Коллекции для работы с многопоточностью.
2.  Java Memory Model - основные аспекты. Garbage Collector. Garbage Collector G1. СMS.
3.  Реализуйте программу на Java, которая принимает на вход файл формата json. В json находится информация о сотрудниках компании по филиалам. Нужно считать данные из json, положить их в класс Employee - каждое поле json в свою переменную-член класса. На основе считанных данных нужно вывести ФИО, возраст, зарплату и филиал тех сотрудников, чей возраст старше 25 лет и с самой низкой зарплатой по филиалу. Обязательно нужно использовать StreamAPI для обработки данных по сотрудникам. Можно пользоваться библиотеками для работы с json. Пример входного файла:
{ [{
        "firstName":"Ivanov"
        "lastName": "Ivan"
        "age":32
        "salary": 10000
        "office": "west"
    },
    {
        "firstName":"Petrov"
        "lastName": "Ivan"
        "age":30
        "salary": 11000
        "office": "west"
    },
    {
        "firstName":"Vetrov"
        "lastName": "Ivan"
        "age":18
        "salary": 9000
        "office": "west"
    },
    {
        "firstName":"Ivanov"
        "lastName": "Daniil"
        "age":32
        "salary": 15000
        "office": "east"
    },
    {
        "firstName":"Petrov"
        "lastName": "Daniil"
        "age":30
        "salary": 11000
        "office": "east"
    },
    {
        "firstName":"Vetrov"
        "lastName": "Daniil"
        "age":18
        "salary": 9000
        "office": "east"
    }]}
Выходные значения:
Ivanov,Ivan,32,1000,west
Petrov,Daniil,30,11000,east
Филиалов может быть много и они могут быть разные. Данные могут быть разные. Не нужно завязываться на конкретный пример.

Билет №3:
1.  Исключения. Обработка исключений. Проверяемые и непроверяемые исключения. Ключевые слова при использовании исключений.
2.  Коллекции Java. Иерархия классов и интерфейсов для коллекций. Примеры.
3.  Реализуйте программу на Java, которая считает медиану чисел. Реализовать клиент и сервер (сокеты). Клиент отправляет набор чисел, сервер принимает запрос от клиента, высчитывает медиану и отправляет обратно клиенту и дальше ждет новых запросов от клиента.

Билет №4:
1.  Сетевое взаимодействие клиент-сервер в Java. Основные классы и методы для работы с сетью.
2.  Stream API. Лямбда-выражения. Основные методы создания, трансформации и агрегации данных.
3.  Реализуйте программу на Java, в которой необходимо сформировать коллекцию с помощью Stream API на основе входных данных. На вход подается строка с любым набором символов. Необходимо с помощью Stream API получить из этой строки коллекцию с типом String, элементами которой являются сумма всех четных чисел из этой строки(в виде строки), конкатенация всех символов нижнего регистра, и отдельно стоящие символы не буквы и не цифры. Пример: На вход подается строка "aV_1,,.-fg.D42!r" на выходе коллекция ["6","afgr","_", ",",",",".","-",".","!"]

Билет №5:
1.  Класс ArrayDeque. Основные реализации. Как работают вставка, удаление, поиск элемента на примере одной из реализаций.
2.  Основные методы для работы с коллекциями. Классы Collections, Arrays.
3.  Реализуйте программу на Java, которая читает два файла в двух разных потоках. Потоки считывают свои файлы и пишут построчно в очередь. Третий поток считывает данные из очереди и создает файл.

Билет №6:
1.  Многопоточность. Интерфейсы Callable, Runnable, Future. Класс Thread.
2.  Неконтроллируемые ресурсы в Java. Интерфейс Autocloseable. try-with-resources. Метод finalize.
3.  Реализуйте программу на Java, в которой необходимо сформировать коллекцию с помощью Stream API на основе входных данных. На вход подается строка с любым набором символов. Необходимо с помощью Stream API получить из этой строки коллекцию с типом String, элементами которой являются сумма всех четных чисел из этой строки(в виде строки), конкатенация всех символов нижнего регистра, и отдельно стоящие символы не буквы и не цифры. Пример: На вход подается строка "aV_1,,.-fg.D42!r" на выходе коллекция ["6","afgr","_", ",",",",".","-",".","!"]

Билет №7:
1.  Интерфейс Set<E>. Основные реализации. Как работают вставка, удаление, поиск элемента на примере одной из реализаций.
2.  Многопоточность. Пуллы потоков. ExecutorService. Executors.
3.  Реализуйте программу на Java, которая запускает отдельный поток на чтение файла, раз в заданное время проверяет изменения в файле и записывает в отдельный файл лог изменений этого файла.

Билет №8:
1.  Файлы в Java. Основные потоки чтения/записи. Основные методы работы с потоками чтения/записи.
2.  Классы, интерфейсы и перечисления. Ключевые слова abstract, interface, enum, default. Разница между абстрактным классом и интерфейсом. Вложенные классы.
3.  Реализуйте программу на Java, которая реализует класс 'грузовик' с характеристиками скорость, объем топливного бака, коллекция груза (LinkedList) - тип груза любой, но все элементы груза - однотипные. Реализовать у класса интерфейсы Comparable, Iterable c учетом характеристик класса.

Билет №9:
1.  Условные операторы(if/else,switch). Операторы циклов (while,do/while,for,foreach,StreamAPI forEach). Интерфейсы Comparable, Comparator. Iterable, Iterator.
2.  Класс Object, его методы, правила переопределения методов, использование класса.
3.  Реализуйте программу на Java, которая читает файл построчно и на каждые считанные 10 строк файла запускает другой поток на анализ самой часто встречаемой буквы. После выполнения всех потоков нужно аккумулировать результаты и выдать самую встречающуюся букву.

Билет №10:
1.  Типы данных. Преобразования типов. Операции box, unbox. Совместимость типов. Internal Buffer.
2.  Параметризация типов. Ковариантность. Контрвариатность. Инвариатность. Использование WildCard.
3.  Реализуйте программу на Java, которая читает два файла в двух разных потоках. Потоки считывают свои файлы и пишут построчно в очередь. Третий поток считывает данные из очереди и создает файл.

Билет №11:
1.  Класс ArrayList, LinkedList. Основные реализации. Как работают вставка, удаление, поиск элемента на примере реализаций.
2.  Наследование, инкапсуляция, полиморфизм. Примеры использования. Ключевое слово final в наследовании. Аннотация @override.
3.  Реализуйте программу на Java, которая запускает отдельный поток на чтение файла, раз в заданное время проверяет изменения в файле и записывает в отдельный файл лог изменений этого файла.,

Билет №12:
1.  Типы данных. Преобразования типов. Операции box, unbox. Совместимость типов. Internal Buffer.
2.  Класс ArrayDeque. Основные реализации. Как работают вставка, удаление, поиск элемента на примере одной из реализаций.
3.  Реализуйте программу на Java, выполняющая частотный анализ текста из файла. Необходимо вывести 10 наиболее часто встречающихся триплетов (3 подряд идущих буквы слова, независимо от регистра) и время работы программы в миллисекундах. Обработка файла должна производиться многопоточно.

Билет №13:
1.  Наследование, инкапсуляция, полиморфизм. Примеры использования. Ключевое слово final в наследовании. Аннотация @override.
2.  Параметризация типов. Ковариантность. Контрвариатность. Инвариатность. Использование WildCard.
3.  Реализуйте программу на Java, которая создает два потока. Первый поток в случайный момент времени пишет свое имя в коллекцию очередь (ArrayDeque), а второй поток в случайный момент времени читает строки из очереди. Примечание: Нельзя использовать коллекции для многопоточности, пользуйтесь стандартными механизмами синхронизации потоков.

Билет №14:
1.  Многопоточность. Интерфейсы Callable, Runnable, Future. Класс Thread.
2.  Неконтроллируемые ресурсы в Java. Интерфейс Autocloseable. try-with-resources. Метод finalize.
3.  Реализуйте программу на Java, которая принимает на вход файл формата json. В json находится информация о сотрудниках компании по филиалам. Нужно считать данные из json, положить их в класс Employee - каждое поле json в свою переменную-член класса. На основе считанных данных нужно вывести ФИО, возраст, зарплату и филиал тех сотрудников, чей возраст старше 25 лет и с самой низкой зарплатой по филиалу. Обязательно нужно использовать StreamAPI для обработки данных по сотрудникам. Можно пользоваться библиотеками для работы с json. Пример входного файла: 
{ [{
        "firstName":"Ivanov"
        "lastName": "Ivan"
        "age":32
        "salary": 10000
        "office": "west"
    },
    {
        "firstName":"Petrov"
        "lastName": "Ivan"
        "age":30
        "salary": 11000
        "office": "west"
    },
    {
        "firstName":"Vetrov"
        "lastName": "Ivan"
        "age":18
        "salary": 9000
        "office": "west"
    },
    {
        "firstName":"Ivanov"
        "lastName": "Daniil"
        "age":32
        "salary": 15000
        "office": "east"
    },
    {
        "firstName":"Petrov"
        "lastName": "Daniil"
        "age":30
        "salary": 11000
        "office": "east"
    },
    {
        "firstName":"Vetrov"
        "lastName": "Daniil"
        "age":18
        "salary": 9000
        "office": "east"
    }]}
Выходные значения:
Ivanov,Ivan,32,1000,west
Petrov,Daniil,30,11000,east
Филиалов может быть много и они могут быть разные. Данные могут быть разные. Не нужно завязываться на конкретный пример.

Билет №15:
1.  Файлы в Java. Основные потоки чтения/записи. Основные методы работы с потоками чтения/записи.
2.  Основные методы для работы с коллекциями. Классы Collections, Arrays.
3.  Реализуйте программу на Java, клиент-серверное (сокеты) приложение. Клиент отправляет на сервер имя файла и ключевое слово. Сервер получает имя файла и ключевое слово. Сервер читает файл, если он есть и отправляет клиенту все строки, в которых есть ключевое слово. Если файла нет или ключевого слова нет, то сервер возвращает ответ, что файла или ключевого слова нет. Сервер постоянно ждёт новых запросов от клиента, клиент постоянно ожидает ввода данных с консоли. Сервер и клиент завершают свою работу только если клиент отправит на сервер команду exit.

Билет №16:
1.  Условные операторы(if/else,switch). Операторы циклов (while,do/while,for,foreach,StreamAPI forEach). Интерфейсы Comparable, Comparator. Iterable, Iterator.
2.  Stream API. Лямбда-выражения. Основные методы создания, трансформации и агрегации данных.
3.  Реализуйте программу на Java, выполняющая частотный анализ текста из файла. Необходимо вывести 10 наиболее часто встречающихся триплетов (3 подряд идущих буквы слова, независимо от регистра) и время работы программы в миллисекундах. Обработка файла должна производиться многопоточно.,

Билет №17:
1.  Многопоточность. Ключевые слова volatile, synchronized. Методы notify, notifyAll, wait.
2.  Интерфейс Map<K,V>. Основные реализации. Как работают вставка, удаление, поиск элемента на примере одной из реализаций.
3.  Реализуйте программу на Java, которая читает файл построчно и на каждые считанные 10 строк файла запускает другой поток на анализ самой часто встречаемой буквы. После выполнения всех потоков нужно аккумулировать результаты и выдать самую встречающуюся букву.

Билет №18:
1.  Класс ArrayList, LinkedList. Основные реализации. Как работают вставка, удаление, поиск элемента на примере реализаций.
2.  Java Memory Model - основные аспекты. Garbage Collector. Garbage Collector G1. СMS.
3.  Реализуйте программу на Java, клиент-серверное (сокеты) приложение. Клиент отправляет на сервер имя файла и ключевое слово. Сервер получает имя файла и ключевое слово. Сервер читает файл, если он есть и отправляет клиенту все строки, в которых есть ключевое слово. Если файла нет или ключевого слова нет, то сервер возвращает ответ, что файла или ключевого слова нет. Сервер постоянно ждёт новых запросов от клиента, клиент постоянно ожидает ввода данных с консоли. Сервер и клиент завершают свою работу только если клиент отправит на сервер команду exit.

Билет №19:
1.  Исключения. Обработка исключений. Проверяемые и непроверяемые исключения. Ключевые слова при использовании исключений.
2.  Библиотека java.util.concurrent.*. Коллекции для работы с многопоточностью.
3.  Реализуйте программу на Java, которая создает два потока. Первый поток в случайный момент времени пишет свое имя в коллекцию очередь (ArrayDeque), а второй поток в случайный момент времени читает строки из очереди. Примечание: Нельзя использовать коллекции для многопоточности, пользуйтесь стандартными механизмами синхронизации потоков.

Билет №20:
1.  Коллекции Java. Иерархия классов и интерфейсов для коллекций. Примеры.
2.  Класс Object, его методы, правила переопределения методов, использование класса.
3.  Реализуйте программу на Java, которая выполняет транформацию отсортированного массива в отсортированный массив квадратов этих чисел за один проход. Пример: (-3,-2,-1,0,2) -> (9,4,4,1,0). Приложение должно быть клиент-серверным. Клиент через сокеты отправляет массив на сервер. Сервер выполняет задачу и отправляет результат клиенту.

Билет №21:
1.  Интерфейс Set<E>. Основные реализации. Как работают вставка, удаление, поиск элемента на примере одной из реализаций.
2.  Сетевое взаимодействие клиент-сервер в Java. Основные классы и методы для работы с сетью.
3.  Реализуйте программу на Java, которая считает медиану чисел. Реализовать клиент и сервер (сокеты). Клиент отправляет набор чисел, сервер принимает запрос от клиента, высчитывает медиану и отправляет обратно клиенту и дальше ждет новых запросов от клиента.
   
Билет №22:
1.  Многопоточность. Пуллы потоков. ExecutorService. Executors.
2.  Классы, интерфейсы и перечисления. Ключевые слова abstract, interface, enum, default. Разница между абстрактным классом и интерфейсом. Вложенные классы.
3.  Реализуйте программу на Java, которая выполняет транформацию отсортированного массива в отсортированный массив квадратов этих чисел за один проход. Пример: (-3,-2,-1,0,2) -> (9,4,4,1,0). Приложение должно быть клиент-серверным. Клиент через сокеты отправляет массив на сервер. Сервер выполняет задачу и отправляет результат клиенту.
