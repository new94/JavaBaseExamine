# JavaBeginTasks
## Ляпин Иван, М8О-311Б-22

### Билет №26:
#### 1.  Интерфейс Set<E>. Основные реализации. Как работают вставка, удаление, поиск элемента на примере одной из реализаций.
- Set<E> представляет из себя реализацию математического множества, данный интерфейс имплементируется в таких коллекциях как HashSet(хеш-таблица для хранения элементов, операции над данной коллекцией работает в среднем за константное время), LinkedHashSet(хеш-таблица, но с сохранением порядка вставки элемента при помощи связного списка),
TreeSet(реализует интерфейс NavigableSet и хранит элемент в кч дереве, операции которого работают за O(logn))

Реализация на основе HashSet:
```Java
public static void main(String[] args) {
        HashSet<String> arr = new HashSet<>();
        arr.add("wow");
        arr.add("meow");
        arr.add("12332");
        arr.add("wow");

        arr.forEach(item -> System.out.println(item));
    }
```
Output: 
```
meow
12332
wow
```
Как видно из вывода, во множестве не содержится дубликатов, а значит повторное добавление "wow" не произошло. 
Принцип всех операций HashSet основан на вычислении значения хеш-функции элемента, типа которого это множества: Например Integer -> Hash (.hashCode())
После чего программа пытается добавить элемент в соостветсвующую ячейку:
- Если она свободна, то смело добавляем
- Если она занята, то применяется метода .equals() для проверки на возможное добавление уже существующего элемента, если элемент уже существует, то повтороное добавление не происходит, если же хеши оказались одинаковыми, но значения элементов разные, то уже данная ячейка превращается в список для разрешения коллизии(вроде как есть даже реализации, где вместо списка юзается сбалансированная древовидная структура, тем самым в худшем случае поиск происходит не за O(n), а O(logn))

при удалении элемента из HashSet Java сначала вычисляет хеш-код элемента, чтобы найти индекс в хеш-таблице. Затем она ищет элемент по этому индексу. Если элемент найден, он удаляется. Если элемент не найден, операция завершится без изменений.

тем самым операции вставки, удаления, поиска зависят напрямую от класса, которые имплементирует данный интерфейс. в хешсете все завязано на вычислении хеш-функии, поэтому все операции работают достаточно быстро, в отличие от того же TreeSet, где лучшее время операций - логарифм.
#### 2.  Многопоточность. Интерфейсы Callable, Runnable, Future. Класс Thread.
Многопоточность является очень важным аспектом в программировании, так как позволяет обрабатывать какой-то конкретный процесс несколькими потоками, которые в свою очередь общаются через средства межпроцессорного взаимодействия и разделяют общую память между собой в рамках процесса. Для потоков существует несколько интерфейсов, которые помогают связать выполнение какой-то задачи внутри процесса:
- Runnable
```Java
class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("123123");
    }
}
```
Интерфейс Runnable представляет из себя контракт с единственным методом run(), которые выполняет конкретную задачу в рамках блока внутри
- Callable
```Java
class MyCallable implements Callable<Integer> {
    @Override
    public Integer call() throws Exception {
        return 806; 
    }
}
```
Интерфейс Callable в свою очередь содержит метод call(), возвращающий результат.

Future:
Интерфейс Future представляет результат асинхронной операции. Интерфейс содержит следующий контракт:
Методы интерфейса Future:
- get(): блокирует текущий поток до тех пор, пока результат не станет доступен
- cancel(boolean mayInterruptIfRunning): пытается отменить выполнение задачи
- isDone(): проверяет, завершена ли задача
- isCancelled(): проверяет, была ли задача отменена

Thread:
Ну и сам поток является классов, который как не странно запускает поток(инструкцию внутри). 
```Java
Thread a = new Thread(
                () -> {
                   // инструкция 
                }
        );
        a.start();
        
        try {
            a.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
```
Пул потоков - своего рода коллекция потоков, при помощи которой можно организовать распределение данных между ними.
```Java
ExecutorService ex = Executors.newFixedThreadPool(NUM_THREADS);
```
Также существует возможность создать коллекцию не фиксированного количество потоков через .newCachedThreadPool(); (есть еще какие-то методы, но их не помню)


3.  Реализуйте программу на Java, которая считает медиану чисел. Реализовать клиент и сервер (сокеты). Клиент отправляет набор чисел, сервер принимает запрос от клиента, высчитывает медиану и отправляет обратно запросившему клиенту и дальше ждет новых запросов от клиента.,
