Билет №7:

Интерфейс Map<K,V>. Основные реализации. Как работают вставка, удаление, поиск элемента на примере 
одной из реализаций.
Коллекции Java. Иерархия классов и интерфейсов для коллекций. Примеры.

Реализуйте программу на Java, которая принимает на вход файл формата json. 
В json находится информация о людях. В одном файле json array с объектами, в которых есть поля: 
ФИО, возраст, пол, номер телефона. Программа должна преобразовать json в класс Java и в отдельном 
потоке найти всех людей, которые старше 18 лет и фамилия имя начинается на букву 'A'. Результат 
вернуть в виде Future и вывести на экран.

1) Интерфейс Map<K,V>. Основные реализации. Как работают вставка, удаление, поиск элемента на примере одной из реализаций.

Интерфейс Map<K, V> представляет отображение, где каждый элемент представляет пару "ключ-значение". 
При этом все ключи уникальные в рамках объекта Map. Такие коллекции облегчают поиск элемента, если нам известен 
ключ - уникальный идентификатор объекта. Следует отметить, что в отличие от других интерфейсов, которые представляют 
коллекции, интерфейс Map НЕ расширяет интерфейс Collection.

Основные Характеристики:
Каждый элемент карты состоит из ключа (K) и связанного с ним значения (V).
Внутри карты все ключи уникальны. Попытка вставить элемент с уже существующим ключом приведёт к замене старого значения новым.
В зависимости от реализации, порядок элементов может быть неопределённым или определённым.

Основные Методы Map<K, V>:
- put(K key, V value): Добавляет пару ключ-значение в карту.
- V get(Object key): Возвращает значение, связанное с указанным ключом.
- V remove(Object key): Удаляет элемент по ключу и возвращает связанное значение.
- boolean containsKey(Object key): Проверяет наличие ключа в карте.
- Set<K> keySet(): Возвращает набор всех ключей.
- Collection<V> values(): Возвращает коллекцию всех значений.
- Set<Map.Entry<K, V>> entrySet(): Возвращает набор всех пар ключ-значение.

HashMap<K, V>:
Особенности:
- Основан на хеш-таблицах.
- Позволяет null ключам и значениям.
- Предоставляет быстрый доступ к элементам: операция поиска, вставки и удаления выполняется за константное время (O(1)) в среднем случае.
- Порядок элементов не гарантируется и может меняться со временем.
Когда использовать:
- Когда приоритетом является скорость доступа.
- Когда порядок хранения элементов не важен.

TreeMap<K, V>:
Особенности:
- Основан на красно-чёрном дереве.
- Не допускает null ключей (начиная с Java 7).
- Хранит элементы в отсортированном порядке согласно естественному порядку ключей или при помощи Comparator.
- Операции поиска, вставки и удаления выполняются за логарифмическое время (O(log n)).
Когда использовать:
- Когда требуется упорядоченное хранение элементов.
- Когда необходим доступ к элементам по диапазону ключей.

LinkedHashMap<K, V>:
Особенности:
- Наследует от HashMap, добавляя поддержание порядка вставки или порядка доступа. 
- Позволяет null ключам и значениям.
- Немного медленнее HashMap из-за дополнительной структуры данных для хранения порядка.
Когда использовать:
- Когда важно сохранять порядок, в котором элементы были добавлены.
- Для реализации кэшей

Пример реализации:
import java.util.HashMap;
import java.util.Map;

public class HashMapExample {
public static void main(String[] args) {
// Создание HashMap
Map<String, Integer> map = new HashMap<>();
// Вставка элементов (put)
        map.put("Яблоко", 10);
        map.put("Банан", 20);
        map.put("Вишня", 30);
// Вывод содержимого карты
        System.out.println("Контент карты: " + map);
// Поиск элемента по ключу (get)
        String keyToFind = "Банан";
        if (map.containsKey(keyToFind)) {
            int value = map.get(keyToFind);
            System.out.println("Значение для ключа '" + keyToFind + "': " + value);
        } else {
            System.out.println("Ключ '" + keyToFind + "' не найден.");
        }
// Удаление элемента по ключу (remove)
        String keyToRemove = "Яблоко";
        if (map.containsKey(keyToRemove)) {
            int removedValue = map.remove(keyToRemove);
            System.out.println("Удален элемент: " + keyToRemove + " = " + removedValue);
        }
// Итерация по карте
        System.out.println("Итерация по карте:");
        for (Map.Entry<String, Integer> entry : map.entrySet()) {
            System.out.println(entry.getKey() + " => " + entry.getValue());
        }
    }

Использовать интерфейс Map для хранения пар ключ-значения.
Использовать класс HashMap, если порядок размещения элементов не важен.
Использовать класс TreeMap, если существует необходимость в сортировке ключей.
Использовать класс LinkedHashMap для сохранения порядка вставки элементов.
В качестве ключа лучше всего Использовать неизменяемые (immutable) объекты, такие как классы String или Integer.
В качестве ключа можно использовать переменную объекта значения.


2) Коллекции Java. Иерархия классов и интерфейсов для коллекций. Примеры.

1. Collection<E>: Основной интерфейс для групп объектов (итерабельных элементов). Непосредственно расширяется следующими интерфейсами:
    - List<E>
    - Set<E>
    - Queue<E>

2. List<E>: Упорядоченная коллекция, допускающая дублирование элементов.
    - Примеры реализации: ArrayList, LinkedList, Vector, Stack.

3. Set<E>: Коллекция, не допускающая дублирование элементов.
    - Примеры реализации: HashSet, LinkedHashSet, TreeSet.

4. Queue<E>: Коллекция для хранения элементов в порядке их обработки (FIFO - First-In-First-Out).
    - Примеры реализации: LinkedList, PriorityQueue, ArrayDeque.

5. Deque<E> (Double Ended Queue): Расширение интерфейса Queue, позволяющее добавлять и удалять элементы с обоих концов.
    - Примеры реализации: ArrayDeque, LinkedList.

6. Map<K, V>: Коллекция, хранящая пары ключ-значение. Не является подинтерфейсом Collection.
    - Примеры интерфейсов и классов: HashMap, TreeMap, LinkedHashMap, Hashtable.

Классы-Реализации Коллекций

1. ArrayList<E>: Реализация интерфейса List, основанная на динамическом массиве. 
Обеспечивает быстрый доступ по индексу, но медленные операции вставки и удаления в середине списка.

2. LinkedList<E>: Реализация интерфейса List и Deque, основанная на двусвязном списке. 
Обеспечивает быстрые вставки и удаления, но медленный доступ по индексу.

3. HashSet<E>: Реализация интерфейса Set, основанная на хеш-таблице. 
Обеспечивает быстрые операции добавления, удаления и поиска, но не гарантирует порядок элементов.

4. LinkedHashSet<E>: Расширение HashSet, сохраняющее порядок вставки элементов.

5. TreeSet<E>: Реализация интерфейса Set, основанная на красно-чёрном дереве. 
Элементы хранятся в отсортированном порядке.

6. HashMap<K, V>: Реализация интерфейса Map, основанная на хеш-таблице. 
Позволяет хранить пары ключ-значение с быстрым доступом по ключу.

7. LinkedHashMap<K, V>: Расширение HashMap, сохраняющее порядок вставки или доступа элементов.

8. TreeMap<K, V>: Реализация интерфейса Map, основанная на красно-чёрном дереве. 
Ключи хранятся в отсортированном порядке.

9. PriorityQueue<E>: Реализация интерфейса Queue, где элементы упорядочены по приоритету.

10. ArrayDeque<E>: Реализация интерфейсов Deque и Queue, основанная на массиве с 
возможностью динамического расширения.

Коллекции в Java реализуются с помощью различных интерфейсов, таких как Collection, List, Set и Map. Эти интерфейсы определяют основные методы для управления группами объектов.

Collection: корневой (root) интерфейс для всех типов коллекций в Java.
Интерфейс Collection расширяет Iterable и является основным интерфейсом для всех типов коллекций в Java. Он предоставляет базовые методы, которые доступны для любой коллекции, включая методы для добавления, удаления и поиска элементов, а также получения размера коллекции.

У JDK нет ни одной прямой реализации этого интерфейса, есть только его наследники интерфейсы, такие как List, Set, и другие.

Все коллекции (за исключением Map), получают следующие методы:

boolean add(E item); – Этот метод используется для добавления элемента в коллекцию. Он возвращает true, если коллекция изменилась в результате вызова.
void clear() – Удаляет все элементы из этой коллекции.
boolean contains(Object item) – Этот метод используется для проверки, содержит ли коллекция указанный элемент.
boolean isEmpty() – Этот метод возвращает true, если коллекция пуста, иначе возвращает false.
boolean remove(Object item) – Этот метод используется для удаления одного экземпляра указанного элемента из этой коллекции, если он присутствует.
int size() – Этот метод возвращает количество элементов в этой коллекции.
Это основные методы, которые предоставляет интерфейс Collection, и которые могут быть использованы для выполнения основных операций над коллекциями.
List: упорядоченная коллекция элементов, допускающая дублирование.
Интерфейс List расширяет Collection и предоставляет широкий спектр методов для манипуляций с элементами коллекции.

Помимо Iterator списки также могут вернуть Listerator, который позволяет использовать вставку и замену элементов, а также двунаправленный доступ.

Рассмотрим основные методы, предоставляемые интерфейсом List:


void add(int index, object obj) – вставляет элемент obj в позицию index. Старые элементы, начиная с позиции index, сдвигаются, их индексы увеличиваются на единицу.
boolean addAll(int index, Collection coll) – вставляет все элементы коллекции coll
object get(int index) – Этот метод используется для получения элемента из списка по указанному индексу.
int indexOf(Object obj) – Возвращает индекс первого вхождения указанного элемента в этом списке или -1, если этот список не содержит элемента.
int lastindexOf(object obj) – Возвращает индекс последнего вхождения указанного элемента в этом списке или -1, если этот список не содержит элемента.
Object set(int index, object obj) – Используется для замены элемента в этом списке на указанной позиции на указанный элемент.
List subList(int from, int to) – возвращает часть коллекции от позиции from включительно до позиции to исключительно.
Set: коллекция элементов, не допускающих дублирования.
Интерфейс Set представляет неупорядоченную коллекцию элементов, в которой каждый элемент является уникальным, то есть без дубликатов. Уникальность элементов проверяется с помощью метода equals(). Интерфейс Set расширяет Collection.

Рассмотрим основные методы, предоставляемые интерфейсом Set:


add(Object o) – Добавляет указанный элемент в это множество, если он еще не присутствует. Если это множество уже содержит указанный элемент, вызов оставляет множество неизменным и возвращает false.
addAll(Collection c) – Добавление элементов коллекции, если они отсутствуют.
clear() – Удаляет все элементы из этого множества. Множество будет пустым после вызова этого метода.
contains(Object o) – Проверка присутствия элемента в наборе. Возвращает true, если элемент найден.
containsAll(Collection c) – Проверка присутсвия коллекции в наборе. Возвращает true, если все элементы содержатся в наборе.
isEmpty() – Возвращает true, если это множество не содержит элементов.
remove(Object o) – Удаляет указанный элемент из этого множества, если он присутствует.
size() – Возвращает количество элементов в этом множестве.
Следует отметить, что, в отличие от интерфейса List, Set не предоставляет методы для доступа к элементам по индексу, поскольку наборы не упорядочены.


Интерфейс Map в Java Collection Framework представляет объект, который хранит пары ключ/значение. Он не является 
частью коллекции, но все еще является частью Collection Framework. В отличие от других интерфейсов, Map не 
наследуется от Collection, поэтому его поведение немного отличается.
Рассмотрим основные методы, предоставляемые интерфейсом Map:
boolean containsKey(Object k) – возвращает true, если коллекция содержит ключ k
boolean containsValue(Object v) – возвращает true, если коллекция содержит значение v
Set<Map.Entry<K, V>> entrySet() – возвращает набор элементов коллекции. Все элементы представляют объект Map.Entry
V get(Object k) – возвращает значение объекта, ключ которого равен k. Если такого элемента не окажется, то 
возвращается значение null
V put(K k, V v) – помещает в коллекцию новый объект с ключом k и значением v. Если в коллекции уже есть объект 
с подобным ключом, то он перезаписывается. После добавления возвращает предыдущее значение для ключа k, если он уже 
был в коллекции. Если же ключа еще не было в коллекции, то возвращается значение null
V putIfAbsent(K k, V v): помещает в коллекцию новый объект с ключом k и значением v, если в коллекции еще нет 
элемента с подобным ключом.
Set<K> keySet() – возвращает набор всех ключей отображения
Collection<V> values() – возвращает набор всех значений отображения
void putAll(Map<? extends K, ? extends V> map) – добавляет в коллекцию все объекты из отображения map
V remove(Object k) – удаляет объект с ключом k
int size() – возвращает количество элементов коллекции
Collections — утилитарный класс из пакета java.util, предоставляющий статические методы для работы с коллекциями, такие как сортировка, поиск, синхронизация и другие полезные операции.
static <T> void sort(List<T> list) - Сортирует список в естественном порядке его элементов.                                     
static <T> void sort(List<T> list, Comparator<? super T> c) - Сортирует список с использованием указанного компаратора.                        
static <T> int binarySearch(List<? extends Comparable<? super T>> list, T key) - Выполняет двоичный поиск элемента в отсортированном списке.                   
Arrays — утилитарный класс из пакета java.util, предоставляющий статические методы для работы с массивами, такие как сортировка, поиск, преобразование массивов в списки и другие операции.
static <T> List<T> asList(T... a) - Преобразует массив в фиксированный по размеру список.                                         
static void sort(int[] a) - Сортирует массив целых чисел в естественном порядке.                                          
static void sort(int[] a, int fromIndex, int toIndex) - Сортирует часть массива.     
