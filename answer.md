Билет №9:

1) Типы данных. Преобразования типов. Операции box, unbox. Совместимость типов. Internal Buffer.
2) Класс ArrayDeque. Основные реализации. Как работают вставка, удаление, поиск элемента на примере одной из реализаций.

1
В языке есть следующие базовые типы данных:
Целые числа:
byte (1 байт) [-128, 127],
short (2 байта),
int (4 байта),
long (8 байт)
Числа с плавающей точкой:
float (4 байта)
double (8 байт)
Символы:
char (2 байта), закоирован в Unicode, (джава создавался как кроссплатформенный язык, который может быть использован по
всему миру,
поэтому стандартного char`a с 1 байтом не хватило бы для "хранения всех языков")
Логические значения:
boolean

Можно определять двоичные, восьмеричные и шестнадцатеричные числа:
int x = 0b111 (двоичный инт) = 7 в десятичной
int y = 07421 (восьмеричный инт) = 3857 в десятичной
int z = 0xa1f (шестнадцатеричный инт) = 2591 в десятичной

При инициализации переменной значением в некоторых случаях необходимо указывать спецификатор типа, например при создании
числа с плавающей точкой изначально подразумевается тип double, однако, чтобы перевести в тип float необходимо сделать
следующее:

float f = 1.666f

Автоматическое преобразования типов происходит, если:

1) оба типа совместимы
2) длина целевого типа больше длины исходного

int a = 5;
long b = a; //все супер, оба условия выполнены

Приведение несовместимых типов:
При приведении вида "(целевой тип) значение" происходит усечение, если размер целевого типа меньше размера исходного.
Усечение происходит по модулю меньшего по размеру типа

long b = 13131;
int a = b; //ошибка

int a = (int) b; //все супер

Продвижением типов называется процесс, при котором при вычислении выражения компилятор выбирает тип выходного значения.
Такое происходит,
если операция в теории даст результат, выходящий за размеры исходных типов.
Правила продвижения типов byte, short, сhar → int → long float → double

short a = 32767;
short b = 31;
var c = a + b; // c имеет тип int

Операции Boxing и unboxing

Упаковка (boxing) примитивных типов в класс: Integer, Long, Byte, Short, Double, Float, Character, Boolean
Представляют собой упаковку значения в класс, классы неизменяемые, поэтому при осуществлении операции сложения
происходит создание нового объекта
Происходит автоматически компилятором
int a = 5;
Integer b = a;

Распаковка (unboxing) — процесс извлечения примитивных значений из-под объектной обертки и преобразования его в
примитивный тип
Integer b = 31;
int a = b;

Internal Buffer, как я понимаю спрашивается про buffered reader и buffered writer?

Механизм, который используется для временного хранения данных, пока они обрабатываются. Это позволяет оптимизировать
производительность ввода-вывода, так как работа с буфером обычно происходит быстрее, чем непосредственная работа с
внешними источниками данных, такими как файлы или сети. Не успеваю расписать до конца...


2
ArrayDeque - реализация двунаправленной очереди в виде массива с переменным числом элементов.

Значения можно добавлять как в конец, так и в начало. Удаление работает по такому же принципу. O(1)
Поиск элемента по индексу за O(1), по значению за O(n).

```java
import java.io.IOException;
import java.net.Socket;
import java.net.UnknownHostException;
import java.util.*;


public class Main {


    public static void main(String[] args) throws IOException {


        ArrayDeque<String> deque = new ArrayDeque<>();


        //добавление элементов

        String temp;

        deque.add("aboba"); //aboba == addLast
        deque.addFirst("РПКС"); //РПКС, aboba
        deque.add("biba"); // РПКС, aboba, biba
        deque.addLast("boba"); //РПКС, aboba, biba, boba
        deque.push("1"); //1, РПКС, aboba, biba, boba


        //удаление элементов

        deque.remove("aboba"); //1, РПКС, biba, boba
        temp = deque.removeFirst(); // РПКС, biba, boba
        temp = deque.removeLast(); // РПКС, biba


        //получение первого элемента без удаления

        String first = deque.getFirst();
        String last = deque.getLast();

        first = deque.peekFirst();
        last = deque.peekLast();

        //с удалением

        first = deque.pop(); // Аналог removeFirst()


        //Проход по деку

        while (deque.peek() != null) {
            first = deque.pop();
        }


        for (String element : deque) { //Но в таком случае нельзя удалять элементы, напечатать не успеваю уже...
            System.out.println(element);
        }

        System.out.println(deque);


    }
}
```





