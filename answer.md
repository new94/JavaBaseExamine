Билет №28:

1) Классы, интерфейсы и перечисления. Ключевые слова abstract, interface, enum, default. Разница между абстрактным классом и интерфейсом. Вложенные классы.
2) Класс Object, его методы, правила переопределения методов, использование класса.

1) Классы, интерфейсы и перечисления. Ключевые слова abstract, interface, enum, default. Разница между абстрактным классом и интерфейсом. Вложенные классы.
Класс в Java — это шаблон для создания объектов. Он может содержать поля, методы, конструкторы и другие компоненты.
Абстрактный класс похож на обычный класс. В абстрактном классе также можно определить поля и методы, но в то же время нельзя создать объект или экземпляр абстрактного класса.
Абстрактные классы призваны предоставлять базовый функционал для классов-наследников. А производные классы уже реализуют этот функционал. Для объявления абстрактных классов используется ключевое слово abstract.

Вложенные классы — это классы, определенные внутри других классов. Они помогают организовать код и инкапсулировать вспомогательные компоненты.

Типы вложенных классов
1. Внутренние классы: Нестатические классы, определенные внутри другого класса.
Особенности:
- Имеют доступ к нестатическим членам внешнего класса.
- Требуют наличия экземпляра внешнего класса для создания экземпляра внутреннего класса.
2. Статические вложенные классы: Статические классы, определенные внутри другого класса.
Особенности:
- Не имеют доступа к нестатическим членам внешнего класса напрямую.
- Могут быть инстанцированы без объекта внешнего класса.
3. Локальные классы: Классы, определенные внутри метода.
Особенности:
- Определяются внутри метода.
- Имеют доступ только к финальным или эффективно финальным переменным метода.
4. Анонимные классы: Безымянные классы, созданные с помощью выражений.
Особенности:
- Безымянные классы, используемые для реализации интерфейсов или наследования классов на лету.
- Часто используются при работе с функциональными интерфейсами.

Интерфейсы определяют некоторый функционал, не имеющий конкретной реализации, который затем реализуют классы, применяющие эти интерфейсы. И один класс может применить множество интерфейсов.
Чтобы определить интерфейс, используется ключевое слово interface.

Интерфейс может определять константы и методы, которые могут иметь, а могут и не иметь реализации. Методы без реализации похожи на абстрактные методы абстрактных классов. 

В JDK 8 была добавлена такая функциональность как методы по умолчанию. И теперь интерфейсы кроме определения методов могут иметь их реализацию по умолчанию, которая используется, если класс, реализующий данный интерфейс, не реализует метод. Метод по умолчанию - это обычный метод без модификаторов, который помечается ключевым словом default.

Перечисления представляют набор логически связанных констант. Объявление перечисления происходит с помощью оператора enum, после которого идет название перечисления. Затем идет список элементов перечисления через запятую

Особенности перечислений
- Компилятор гарантирует, что переменная типа enum может принимать только значения, определенные в перечислении.
- Перечисления могут содержать методы, конструкторы и поля.
- Перечисления могут реализовывать интерфейсы.

Разница между абстрактным классом и интерфейсом:
- Интерфейсы описывают только часть функциональности объекта — определённые признаки. Абстрактный класс же может описывать целую категорию разных объектов, а его характеристики имеют право наследовать только те объекты, которые являются частью этой категории. Например, собаки и волки — часть общей категории «Животные», а интерфейс, описывающий умение бегать, может реализовать и человек, и робот, и собака.
- Интерфейс описывает только поведение (методы), и у него нет полей. Точнее, есть возможность их объявить, но они будут public static final. В то же время абстрактный класс может содержать классические поля, которые будут принадлежать разным объектам.
- Наследник абстрактного класса обязан наследовать все его составляющие, а интерфейс создан только для реализации (имплементирования). Поэтому в Java мы можем наследовать класс только от одного класса, а на реализацию интерфейсов внутри одного класса ограничений нет.


2) Класс Object, его методы, правила переопределения методов, использование класса.
Фактически все классы наследуются от класса Object. Все классы, которые мы добавляем в свой проект, являются неявно производными от класса Object.
Поэтому все типы и классы могут реализовать те методы, которые определены в классе Object.

Методы Object

часто используемые:
- toString()
- equals()
- hashCode()

сихронизация потоков:
- notify() (Пробуждает один поток, ожидающий на мониторе данного объекта.)
- notifyAll() (Пробуждает все потоки, ожидающие на мониторе данного объекта)
- wait() ()

- getClass

- clone()
- finalize()

Метод toString служит для получения представления объекта в виде строки. 
Для строк этот метод возвращает саму строку. А вот для других объектов toString() возвращает стандартное представление, состоящее из имени класса и хеша.
Но можно изменить это поведение, реализовав метод toString() внутри нашего класса. Таким образом мы переопределим метод родительского класса.

Метод getClass позволяет получить тип данного объекта:

Person tom = new Person("Tom");
System.out.println(tom.getClass()); // class Person

Возвращает объект Class, представляющий класс runtime объекта. Этот метод нельзя переопределять.

Метод hashCode позволяет задать некоторое числовое значение, которое будет соответствовать данному объекту или его хэш-код. По данному числу, например, можно сравнивать объекты.
Person tom = new Person("Tom");
System.out.println(tom.hashCode()); // 2036368507

Возвращает хеш-код объекта. По контракту, одинаковые объекты должны иметь одинаковый хеш-код.

Метод equals сравнивает два объекта на равенство

При переопределении метода equals, необходимо также переопределить и метод hashCode, чтобы поддерживать общий контракт между ними. Если два объекта считаются равными по методу equals, то их хеш-коды также должны быть равными.

При переопределении этих методов следует учесть несколько важных моментов:
Симметричность: Если один объект равен другому, то и второй объект должен быть равен первому. Это обеспечивается правильной реализацией метода equals (если a.equals(b), то b.equals(a)).
Транзитивность: Если первый объект равен второму, и второй объект равен третьему, то первый объект должен быть равен третьему. Это также обеспечивается корректной реализацией метода equals (если a.equals(b) и b.equals(c), то a.equals(c)).
Консистентность: Если информация, используемая в методах equals и hashCode, не изменяется, то многократные вызовы этих методов должны возвращать одинаковые результаты.
Не равенство к null: Объект должен быть не равен null. Метод equals должен возвращать false, если его параметр null (a.equals(null) должно возвращать false).
Соответствие между equals и hashCode: Если два объекта равны по методу equals, то и их хеш-коды должны быть равны.




 