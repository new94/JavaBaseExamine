Билет 25
Неконтроллируемые ресурсы в Java. Интерфейс Autocloseable. try-with-resources. Метод finalize.
Неконтроллируемые ресурсы — это ресурсы, которые не управляются JVM напрямую и требуют явного освобождения программой. К таким ресурсам относятся:

- Файловые дескрипторы: Работа с файлами, директориями.
- Сетевые соединения: Соединения по протоколам TCP/IP, UDP и другие.
- Базы данных: Соединения с базами данных через JDBC.
- Потоки ввода-вывода: InputStream, OutputStream, Reader, Writer и их производные.
- Сокеты: Socket, ServerSocket и т.д.
- Драйверы графических устройств: Например, в графических приложениях.

Проблема: Если такие ресурсы не освобождены после использования, это может привести к утечкам ресурсов, снижению производительности и даже сбоям приложения.

AutoCloseable — это интерфейс из пакета java.lang, введенный в Java 7. Он предоставляет механизм для автоматического освобождения ресурсов после их использования.

public interface AutoCloseable {
      //Метод вызывается автоматически после выхода из блока try, который
     //использует ресурс, реализующий этот интерфейс.
     //@throws Exception Если возникает исключение при закрытии ресурса.
    void close() throws Exception;
}

Цель интерфейса AutoCloseable

- Унификация: Позволяет любому классу, управляющему ресурсами, быть использованным в конструкции try-with-resources.
- Безопасность: Обеспечивает гарантированное закрытие ресурсов, даже если в блоке try возникает исключение.
- Простота: Упрощает написание кода для управления ресурсами.

Классы, реализующие AutoCloseable

Многие стандартные классы Java, которые управляют ресурсами, реализуют AutoCloseable:

- FileInputStream, FileOutputStream
- BufferedReader, BufferedWriter
- Connection (из JDBC)
- Statement и ResultSet (из JDBC)
- Scanner
- Пользовательские классы, управляющие ресурсами

Пример
public class MyResource implements AutoCloseable {
    public MyResource() {
        System.out.println("Ресурс открыт");
    }

    public void doSomething() {
        System.out.println("Ресурс используется");
    }

    @Override
    public void close() {
        System.out.println("Ресурс закрыт");
    }
}

public class AutoCloseableExample {
public static void main(String[] args) {
        try (MyResource resource = new MyResource()) {
            resource.doSomething();
        }
    }
}

Конструкция try-with-resources
try (ресурс1; ресурс2; ...) {
    // Использование ресурсов
} catch (Исключение e) {
    // Обработка исключений
} finally {
    // Дополнительная очистка (опционально)
}


try-with-resources — это конструкция, введенная в Java 7, которая автоматически управляет ресурсами, реализующими интерфейс AutoCloseable (или его подинтерфейс Closeable). Эта конструкция гарантирует, что ресурсы будут закрыты автоматически при выходе из блока try, независимо от того, возникло там исключение или нет.

Если в блоке try возникает одно исключение, а при закрытии ресурсов — другое, то второе исключение добавляется как подчинённое (suppressed) к первому. Это позволяет сохранить информацию обо всех возникающих проблемах.

До введения конструкции try-with-resources и интерфейса AutoCloseable, для освобождения ресурсов использовался метод finalize класса Object.

Назначение метода finalize

- Освобождение ресурсов: Позволял разработчикам определить логику освобождения ресурсов перед сборкой мусора объекта.
- Очистка: Возможно использование для освобождения нежелательных ресурсов или выполнения действий перед уничтожением объекта.

Проблемы метода finalize

1. Непредсказуемость: Время вызова метода finalize не гарантировано, поскольку зависит от работы сборщика мусора.
2. Низкая производительность: Сборщик мусора тратит дополнительные ресурсы на вызов finalize.
3. Ненадёжность: Если объект отклоняет исключение в finalize, это может привести к прекращению вызовов finalize для этого и других объектов.
4. Зависимость от сборщика мусора: Необходимо полагаться на сборщик мусора для освобождения ресурсов, что противоречит принципу явного управления ресурсами.
5. Депрецированный: Начиная с Java 9, метод finalize объявлен устаревшим (deprecated) и его использование не рекомендуется.

Пример:
public class FinalizeExample {
    @Override
    protected void finalize() throws Throwable {
        try {
            // Освобождение ресурса
            System.out.println("Finalize: Ресурс освобожден");
        } finally {
            super.finalize();
        }
    }

    public static void main(String[] args) {
        FinalizeExample example = new FinalizeExample();
        example = null; // Делаем объект доступным для сборки мусора

        // Запускаем сборщик мусора
        System.gc();

        // Ожидание для демонстрации вызова finalize
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Конец программы");
    }
}



Stream API. Лямбда-выражения. Основные методы создания, трансформации и агрегации данных.

Stream API используется для упрощения работы с набором данных, например, для упрощения фильтрации, сортировки и других манипуляций с данными. Для его использования нужен пакет java.util.stream. Ключевым понятием в Stream API является поток данных, поток представляет собой канал передачи данных из источника данных, причем источником могут выступать как файлы, так и массивы и коллекции.

Пример:

import java.util.stream.*;
//.......................
long count = IntStream.of(-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5).filter(w -> w > 0).count();
System.out.println(count);

Операции бывают либо терминальными (terminal) либо промежуточными (intermediate). Промежуточные операции возвращают трансформированный поток, в примере выше метод filter принимал поток и возвращал уже преобразованный поток, в котором только числа большие 0. К возвращенному потоку также можно применить ряд промежуточных операций.

Конечные или же терминальные операции возвращают уже конкретный результат, например в примере выше метод cout() представляет собой терминальную операцию и возвращает число, после этого никаких промежуточных операций применять нельзя.

В основе Stream API лежит интерфейс BaseStream. Его полное определение:
interface BaseStream<T , S extends BaseStream<T , S>>
Здесь параметр T означает тип данных в потоке, а S - тип потока, который наследуется от интерфейса BaseStream.
Одной из отличительных черт Stream API является применение лямбда-выражений, которые позволяют значительно сократить запись выполняемых действий.
Лямбда представляет набор инструкций, которые можно выделить в отдельную переменную и затем многократно вызвать в различных местах программы.
Основу лямбда-выражения составляет лямбда-оператор, который представляет стрелку ->. Этот оператор разделяет лямбда-выражение на две части: левая часть содержит список параметров выражения, а правая собственно представляет тело лямбда-выражения, где выполняются все действия.

Лямбда-выражение не выполняется само по себе, а образует реализацию метода, определенного в функциональном интерфейсе. При этом важно, что функциональный интерфейс должен содержать только один единственный метод без реализации.
Синтаксис лямбда-выражения:
(parameters) -> expression или (parameters) -> { statements; }
Лямбда-выражение может использовать переменные, которые объявлены во вне в более общей области видимости - на уровне класса или метода, в котором лямбда-выражение определено. Однако в зависимости от того, как и где определены переменные, могут различаться способы их использования в лямбдах.
Для фильтрации элементов потока на основе условия используется filter.
//Фильтрация четных чисел
import java.util.Arrays;
import java.util.List;
public class FilterExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        numbers.stream()
               .filter(n -> n % 2 == 0)
               .forEach(System.out::println);
    }
}

также есть:
sorted - сортирует элементы потока. Без параметров — естественный порядок, с параметром — по заданному компаратору.
collect - собирает элементы потока в коллекцию или другую структуру данных

